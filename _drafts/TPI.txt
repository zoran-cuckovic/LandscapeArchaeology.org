Topographic position index : a numpy based implementation

VIDI TPI test vec napravljen !!



Topographic position index is a method of terrain classification where the altitude of each data point is evaluated against its neighbours. If the point is higher than its surroundings, the index will be positive, otherwise it will be negative (e.g. for valley bottoms). The 



But why should we code? TPI is today included in typical GIS software, such as QGIS, GRASS, ArcGis or Saga. 
That's great, but let'c consider the method under the hood. TPI is, in fact, only a simple image filter, just like many others that are widely used in image analysis [see on wikipedia](https://en.wikipedia.org/wiki/Kernel_(image_processing)). Such "kernel" or "sliding window" approaches usually 
neighbourhood

Should'nt it be grat to combine  

https://en.wikipedia.org/wiki/Kernel_(image_processing)

http://www.jennessent.com/downloads/TPI-poster-TNC_18x22.pdf => original publication !!

IMG : http://www.jennessent.com/downloads/tpi_documentation_online.pdf
De Reu topographic position !!

To test the script you can use QGIS (open the console .....) or use in Python (

CODE 
```
import gdal
import numpy as np

"""
Topographic position index for elevation models, 
a mock script to be tuned according to you needs.

All comments are welcome at landscapearchaeology.org/2019/tpi
"""

# -------------- INPUT -----------------
elevation_model ="__path__to__my__dem__"
radius_pixels= 5
output_model = "__path__to_my__output__file__"


def view (offset_y, offset_x, shape, step=1):
    """
    Function returning two matching numpy views for moving window routines.
    - 'offset_y' and 'offset_x' refer to the shift in relation to the analysed (central) cell 
    - 'shape' are 2 dimensions of the data matrix (not of the window!)
    - 'view_in' is the shifted view and 'view_out' is the position of central cells
    """
    size_y, size_x = shape
     
    x, y = abs(offset_x), abs(offset_y)
    
    x_in = slice(x , size_x, step) 
    x_out = slice(0, size_x - x, step)

    y_in = slice(y, size_y, step)
    y_out = slice(0, size_y - y, step)
 
    # the swapping trick    
    if offset_x < 0: x_in, x_out = x_out, x_in                                 
    if offset_y < 0: y_in, y_out = y_out, y_in
 
    # return window view (in) and main view (out)
    return np.s_[y_in, x_in], np.s_[y_out, x_out]

# ----  main routine  -------

dem= gdal.Open(elevation_model)
mx_z= dem.ReadAsArray()

r = radius_pixels

# moving window (we don't really need it for this calcualtion...)
win = np.zeros((2*r +1, 2*r +1))

mx_temp = np.zeros(mx_z.shape)
mx_count = np.zeros(mx_z.shape).astype(int)

# loop through window and accumulate values
for (y,x), some_value in np.ndenumerate(win):

    if x == r and y == r : continue  #skip the center pixel
    
    view_in, view_out = view(y-r, x-r, mx_z.shape)

    mx_temp[view_out] += mx_z[view_in] # * some_value if you whish...
   
    mx_count[view_out] += 1

out = mx_z - mx_temp / mx_count

# writing output 
driver = gdal.GetDriverByName('GTiff')
c = driver.CreateCopy(output_model, dem, 0) 
c.GetRasterBand(1).WriteArray(out)
c= None

```